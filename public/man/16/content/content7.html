<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Менеджмент проектов программного обеспечения — Теория — Метод объектных точек</title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/help-system1.html">Подсистема помощи</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Менеджмент проектов программного обеспечения</div><div id="courseSubTitle">Раздел 16 - Оценка размера и возможности повторного использования ПО : Метод объектных точек</div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><a href="../../16/content/preface1.html">Введение</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../16/content/content1.html">Введение</a></li><li><a href="../../16/content/content2.html">Проблемы и риски, связанные с оцениванием размера ПО</a></li><li><a href="../../16/content/content3.html">Определение размеров программного продукта</a></li><li><a href="../../16/content/content4.html">Оценка размера ПО в процессе разработки проекта </a></li><li><a href="../../16/content/content5.html">Метод функциональных точек</a></li><li><a href="../../16/content/content6.html">Метод точек свойств</a></li><li><a href="../../16/content/content7.html">Метод объектных точек</a></li><li><a href="../../16/content/content8.html">Метод оценивания Wideband Delphi</a></li><li><a href="../../16/content/content9.html">Влияние эффектов повторного использования на размер ПО </a></li><li><a href="../../16/content/content10.html">Резюме </a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../16/content/example1.html">Вопросы для самопроверки</a></li></ul><li><a href="../../16/content/conclusion1.html">Выводы</a></li><li><a href="../../16/styles/reference.html">Перечень ссылок</a></li><li><a href="../../16/16.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnk8a0770810b8d48c1bbcf0c8e39652ecc"> </span><h1 align="left" class="headline-source">Метод объектных точек</h1><span id="lnkf0d719bc61e542a2afa56aeae5b26e47"> </span><div class="section"><p align="justify" class="paragraph-source">     Подход с использование подсчета "объектных точек" для определения размера ПО позаимствован из объектно-ориентированной технологии. При использовании этого подхода оценка выполняется на более обобщенном уровне, чем в случае с функциональными точками. В данном случае каждому уникальному классу или объекту (экран, выводимый отчет и т.д.) назначается одна объектная точка. В остальном этот метод подобен методу функциональных точек и точек свойств, лишь следует учесть, что применяются различные факторы преобразования. </p><p align="justify" class="paragraph-source">     <i><b>Блиц-модель</b></i><i><b>. </b></i></p><p align="justify" class="paragraph-source">     Оценка, выполняемая на каждой фазе проекта, будет более качественной в случае, если доступен больший объем исходных данных. Влияние исходных знаний особенно хорошо заметно на стадии анализа и проектирования, на которых обычно формируются модели (глава 22). Здесь особенно хорошо заметно, что от количества начальных данных зависит точность оценки размера ПО. Еще до того, как будет достигнута текущая стадия проекта, могут оказаться весьма полезными некоторые модели высокого уровня, созданные на фазе планирования. Эти модели могут применяться в качестве быстрого и простого метода оценки размера ПО. </p><p align="justify" class="paragraph-source">     Концепция блиц-моделирования основана на банг-метрике. В этом случае грубые оценки размера программного кода определяются путем подсчета компонентных частей системы (элементов дизайна) и дальнейшим умножением результата на множитель производительности (как правило, этот множитель определяется на основе хронологических данных и определяет количество строк процедурного кода, необходимых для реализации алгоритма). </p><p align="justify" class="paragraph-source">     Например, если данные высокого уровня в схеме последовательности операций либо в объектных моделях генерируются в качестве части исследования концепции или планирования, их компоненты могут быть просмотрены на предмет их размера. </p><p align="justify" class="paragraph-source">     Представьте себе, что 20 классов объектов и их характеристики получаются путем наблюдения существующих систем и реализованы как средние величины в качестве пяти процедурных программ из расчета на один класс. Также путем наблюдения за существующими системами стало известно, что средний размер процедурной программы (язык С) равен 75 LOC. Затем размер может быть быстро вычислен следующим образом: </p><p align="justify" class="paragraph-source"></p><p align="center" class="paragraph-source">     <i><b>Количество процессов (классы объекта) * количество программ из расчета на класс * размер средней программы = расчетный размер </b></i></p><p align="center" class="paragraph-source"></p><p align="center" class="paragraph-source">     <i><b>20 </b></i><i><b>классов объекта * 5 программ на класс * 75 строк LОC на программу = 7500 вычисленных LОC </b></i></p><p align="center" class="paragraph-source"></p><p align="justify" class="paragraph-source">     Приведенные выше выкладки известны как "блиц", примененный по отношению к документам, созданным на ранних стадиях. Компоненты любой модели ("пузырьки" процесса, потоки данных, репозитории данных, сущности, взаимосвязи, объекты, атрибуты, службы и т.д.) могут умножаться на множитель, который вычисляется как результат выполнения предыдущих проектов. </p><p align="justify" class="paragraph-source">     А теперь рассмотрим другие примеры. Если известно, что каждый "пузырек" процесса на уровне 0 <b>DFD,</b> приблизительно соответствует четырем фактическим программам на языке SQL, а также известно, что средний размер программ в библиотеке SQL равен 350 строкам LOC, поэтому простое умножение будет достаточным для подсчета начального размера. Известно, что в данном случае существует семь основных "пузырьков" процесса:</p><p align="justify" class="paragraph-source">     <i><b>Примечание</b></i><i>. </i><i>Метод совместной разработки приложений (JAD) - это зарегистрированный товарный знак, относящийся к компании IBM. Сеанс JAD имеет определенную структуру, на нем придерживаются определенной дисциплины, и он проходит под руководством арбитра. В его основе лежит обмен информацией с использованием документации, фиксированных требований и правил работы. С момента появления методики JAD на сеансах используются CASE- инструменты и другие программные средства, предназначенные для построения </i><i><b>диаграмм потока данных (Data flow diagram, DFD)</b></i><i>, </i><i>диаграмм взаимосвязей между сущностями (Entity relationship diagrams, ERD), диаграмм смены состояний и других объектно-ориентированных диаграмм.</i></p></div><span id="lnkd8e70a9ec04843979d5088f44cd8ed4f"> </span><div class="section"><p align="center" class="paragraph-source"><i><b>Количество процессов ("пузырьки" DFD) * количество программ на "пузырек" * размер средней программы = вычисленный размер </b></i></p><p align="center" class="paragraph-source"></p><p align="center" class="paragraph-source"><i><b>7 "</b></i><i><b>пузырьков" * 4 программы на "пузырек" * 350 строк LOC на программу 9800 вычисленных строк LOC </b></i></p><p align="justify" class="paragraph-source">     Если глобальная модель высокого уровня продуцируется на этапе определения времени выполнения, а на основе исторического опыта известно, что каждая служба соответствует двум программам на языке C++, а стандарты компании ограничивают каждый размер служебного пакета величиной в 100 строк LOC и менее, приведенная ниже формула обеспечивает хорошую начальную базу для оценивания размера систем, выраженного в количестве строк LOC: <i><b> number of services * 2 * 100 </b></i></p><p align="justify" class="paragraph-source">     В данном случае ключевой является фраза "на базе исторического опыта". База данных, содержащая данные за достаточно долгий период времени, является весьма важной в деле повышения точности оценки. При этом база данных должна содержать запись, соответствующую фактическому размеру каждого программного компонента. </p><p align="justify" class="paragraph-source">     Объем трудозатрат, понесенных на создание компонента данного размера, также должен отслеживаться. По мере роста количества точек данных, улучшается степень соответствия среднего количества строк LOC из расчета на программу со средним объемом трудозатрат, понесенных при создании компонента. Как только станут известными размеры фактических компонентов и величины объемов соответствующих усилий, затраченных на этапе разработки, становится известной также средняя "производительность" (размер/трудозатраты). </p><p align="justify" class="paragraph-source">     При использовании банг-метрики системы, использующие множество функций (в том числе и системы реального времени), должны оцениваться отдельно от систем, обрабатывающих большие объемы данных. При оценке функционально богатых систем в качестве базисных значений используется количество неделимых функциональных примитивов, как определено с помощью схемы информационных потоков. Системы, обрабатывающие большое количество данных, в качестве базисных значений используют количество объектов в модели данных, глобальных на системном уровне. При этом также применяются весовые множители (Weighting factor, WF). </p><p align="justify" class="paragraph-source">     Ниже приводится пример функционально богатой системы: множитель WF (среднее количество модулей, требуемых для завершения функции) равен трем, количество процессов плюс спецификации контроля (функции) равно восьми, а средний размер одной функции равен 78 LOC. Затем воспользуемся следующей формулой: </p><p align="justify" class="paragraph-source"></p><p align="center" class="paragraph-source"><i><b>WF * (</b></i><i><b>количество процессов и спецификаций контроля) * среднее количества LOC для данного модуля = LOC </b></i></p><p align="center" class="paragraph-source"></p><p align="center" class="paragraph-source"><i><b>3 </b></i><i><b>модуля, требуемые для функции * 8 функций * 78 LОC = 1,872 LOC </b></i></p><p align="center" class="paragraph-source"></p><p align="justify" class="paragraph-source">     Чем же все это отличается от анализа методом функциональных точек, представленного на фазе определения области осуществимости? Менеджер проекта может выбрать выполнение анализа точек свойств во время фазы определения области выполнения, когда существуют только модели высокого уровня, такие как DFD уровня содержимого. Затем полученная оценка улучшается на фазе планирования, когда доступен больший объем знаний о проекте и дополнительная документация, например DFD уровня 0 наравне с DFD уровня 1 для некоторых из основных подсистем. Любые из этих моделей могут применяться на протяжении любой фазы. Если они применяются последовательно, повышается ожидаемая точность измерений и получения оценок.</p></div><span id="lnkff9b8b3f01354a088ddb460a704df40d"> </span><h2 align="left" class="paragraph-headline-source">Преимущества блиц-модели </h2><span id="lnk88e0cca5d48d42feab9f3fbd45405f00"> </span><div class="section"><ul class="list-source"><li align="justify">Облегчается использование структурных систем (схемы информационных потоков, диаграммы взаимосвязи сущностей) совместно с объектно-ориентированными классами, службами и т.д. </li><li align="justify">Повышается степень точности при использовании хронологических данных.</li><li align="justify">Действия по непрерывному улучшению используются при реализации техники оценки.</li><li align="justify">Оцененный размер может быть легко сопоставлен с фактическим размером при выполнении постпроектного анализа. (Насколько точной была оценка? Каков процент возможного отклонения? Что потребуется освоить при оценке размера следующего проекта?) </li></ul></div><span id="lnkb51ed85937924f0cb6ac926f8ac29ea8"> </span><h2 align="left" class="paragraph-headline-source">Недостатки блиц-модели </h2><span id="lnk89026b712fdc4897bc1f5ba8b4ce45ea"> </span><div class="section"><ul class="list-source"><li align="justify">Требуется использование методологии дизайна. </li><li align="justify">Оценка не может начинаться до завершения разработки дизайна. </li><li align="justify">Требуются хронологические данные.</li><li align="justify">Не могут оцениваться факторы среды.     </li></ul></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2005 ХНУРЭ, Программной инженерии, Ревенчук Илона Анатольевна, <a href="mailto:fpo@kture.kharkov.ua">fpo@kture.kharkov.ua</a><br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>