<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Менеджмент проектов программного обеспечения — Теория — Оценка размера ПО в процессе разработки проекта </title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/help-system1.html">Подсистема помощи</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Менеджмент проектов программного обеспечения</div><div id="courseSubTitle">Раздел 16 - Оценка размера и возможности повторного использования ПО : Оценка размера ПО в процессе разработки проекта </div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><a href="../../16/content/preface1.html">Введение</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../16/content/content1.html">Введение</a></li><li><a href="../../16/content/content2.html">Проблемы и риски, связанные с оцениванием размера ПО</a></li><li><a href="../../16/content/content3.html">Определение размеров программного продукта</a></li><li><a href="../../16/content/content4.html">Оценка размера ПО в процессе разработки проекта </a></li><li><a href="../../16/content/content5.html">Метод функциональных точек</a></li><li><a href="../../16/content/content6.html">Метод точек свойств</a></li><li><a href="../../16/content/content7.html">Метод объектных точек</a></li><li><a href="../../16/content/content8.html">Метод оценивания Wideband Delphi</a></li><li><a href="../../16/content/content9.html">Влияние эффектов повторного использования на размер ПО </a></li><li><a href="../../16/content/content10.html">Резюме </a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../16/content/example1.html">Вопросы для самопроверки</a></li></ul><li><a href="../../16/content/conclusion1.html">Выводы</a></li><li><a href="../../16/styles/reference.html">Перечень ссылок</a></li><li><a href="../../16/16.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnk9f4a2e5ee0a540e6b3644b59e773b4b0"> </span><h1 align="left" class="headline-source">Оценка размера ПО в процессе разработки проекта </h1><span id="lnk058d616e30f84014b70e28b27e7cfb1c"> </span><h2 align="left" class="paragraph-headline-source">Оценка показателя LOC с помощью экспертных заключений и восходящего суммирования</h2><span id="lnk85e33a1770a9471badb6f3f8dd74c2d1"> </span><div class="section"><p align="justify" class="paragraph-source">     Пусть структура WBS содержит несколько уровней декомпозиции в иерархии продукта/проекта. Требования к иерархии продуктов WBS могут быть разбиты на фактические компоненты программных систем. </p><p align="justify" class="paragraph-source">     Максимально детализированная структура WBS может принести пользу на стадии точных измерений, за которой следует стадия точных оценок.</p><p align="justify" class="paragraph-source">     Как только структура WBS будет разбита с учетом выделения самых нижних уровней, может быть создан "статистический" показатель размера. </p><p align="justify" class="paragraph-source">     При этом используются процессы измерения и суммирования. Величина размера каждого компонента может быть получена путем опроса экспертов, разрабатывавших подобные системы, либо путем использования данных опроса потенциальных разработчиков подобных систем. В результате становится возможной оценка размеров каждого блока на нижних уровнях структуры WBS. </p><p align="justify" class="paragraph-source">     После сложения результатов измерений полученный итог будет называться оценкой размера "снизу-вверх". Улучшенная оценка может быть получена в том случае, если каждый оценщик произведет оптимистическую, пессимистическую и реалистическую оценку размеров. Затем формируется бета-распределение путем умножения реалистической оценки размера на 4, добавления оптимистической и пессимистической оценок с последующим делением результата на 6. Подобное взвешенное среднее значение является удобным в условиях естественной неопределенности процесса оценивания. </p><p align="justify" class="paragraph-source">     <i>Например,</i> если данный оконный объект отображается в структуре WBS для системы, поддерживающий код, который требуется для реализации процесса редактирования в данном окне, может занимать от 200 до 400 строк кода, причем, скорее всего эта цифра окажется более близкой к 250. Учитывая предложенные оценщиком пессимистические и оптимистические сценарии, можно получить следующую итоговую оценку: </p><p align="justify" class="paragraph-source">ПО - Пессимистическая оценка размеров,</p><p align="justify" class="paragraph-source">ОО - Оптимистическая оценка размеров,</p><p align="justify" class="paragraph-source">РО - Реалистическая оценка размеров,</p><p align="justify" class="paragraph-source">(ПО+ОО+(РО*4))/6= LOC</p><p align="justify" class="paragraph-source">(200 + 400 +(250*4))/6 = 266,67=266 LOC </p><p align="justify" class="paragraph-source">     Количество тысяч строк исходного кода (KSLOC) является производным от общей метрики, вводимой при оценках производительности. </p><p align="justify" class="paragraph-source">     Обычно производительность выражается в KSLOC/SM либо KLOC/SM (где SM - staff-month (человеко-часы)).</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">     Подсчет строк существующего кода вручную является достаточно утомительным и длительным занятием. В силу этого многие организации приобретают либо разрабатывают автоматизированные LOC-счетчики. </p><p align="justify" class="paragraph-source">     Подсчет вручную: </p><ul class="list-source"><li align="justify">Каждая учитываемая "строка исходного кода" должна содержать лишь один оператор (если в одной строке содержатся два выполняемых оператора, разделяемых точкой с запятой, то будут учитываться две строки; если же один выполняемый оператор разбит на две "физические" строки, он будет учитываться как один оператор). В языках программирования допускаются все опции кодирования, но обычно проще определять в строке один выполняемый оператор, обрабатываемый компилятором либо интерпретатором. </li><li align="justify">Необходимол учитывать все имеющиеся выполняемые операторы- конечный пользователь может не иметь возможности непосредственно использовать каждый оператор, но все операторы должны поддерживаться данным продуктом (в том числе и утилитами). </li><li align="justify">Определение данных учитывается лишь один раз. </li><li align="justify">Не учитываются строки, содержащие комментарии. </li><li align="justify">Не учитывается отладочный код либо любой другой временный код (пробное ПО, средства тестирования, инструменты разработки и прототипирования, а также другие подобные средства). </li><li align="justify">Необходимо учитывать каждую инициализацию, вызов либо включение (иногда называемое директивой компилятора) макроса в качестве части исходного кода, в котором осуществляется то либо иное действие (не учитывайте повторно используемые операторы исходного кода). </li><li align="justify">Трансляция количество строк исходного кода в эквивалентные строки языка ассемблера, даст вам возможность одновременно выполнять сравнительный анализ для нескольких проектов.      </li></ul></div><span id="lnkeebac8f201c94d4886e2273eed2ef7c5"> </span><div class="section"><p align="justify" class="paragraph-source">     Первый и второй столбцы таблицы рисунка. 16.2 представляют метод трансляции SLOC, применяемый в различных языках по отношению к среднему количеству строк SLOC в базовом языке ассемблера. (Обратите внимание, что SLOC и LOC являются взаимозаменяемыми.) Большинство менеджеров проектов предпочитают выполнять трансляцию с языков программирования на базовый язык ассемблера по той простой причине, что в этом случае операции сравнения во многих проектов могут производиться на идентичной основе. Эти данные могут быть полезными также в случае трансляции проекта с обычного языка программирования на язык преобразования. </p></div><span id="lnkfdc7b40b84f341b3ae0ec734d3ca94c7"> </span><div class="section"></div><span id="lnk485d6e705c4f4d7aa53183c0f9fbb300"> </span><p align="center" class="inline-picture-source"><img src="../res/files/ris_16x2_0_.JPG" height="700px" width="504px" alt="" /> </p><p align="center" class="inline-picture-source"></p><p align="center" class="inline-picture-source">Рисунок 16.2 - Показатели SLOC при преобразовании кода с языка программирования на язык Basic Assembler SLOC из расчета на одну функциональную точку</p><span id="lnk7ac3509d89de42d98f100b8c1c0157c9"> </span><div class="section"></div><span id="lnk2d20aafeee9c47c996456b5ccfbe8981"> </span><div class="section"><p align="justify" class="paragraph-source">     <i>Например, </i>предположим, что операционная система, написанная на языке С и насчитьшающая 50 000 строк LOC, будет преобразована в C++. Руководствуйтесь сведениями из табл. 10.1, где базовый показатель SLOC языка С относительно языка ассемблера равен 2.5. Поэтому операционная система, содержащая 50000 строк SLOC, написанных на С, будет эквивалентной 125000 строкам в случае использования языка ассемблера (50,000 х 2.5). Если же 125000 строк операционной системы на языке ассемблера были переписаны с учетом использования языка C++, получим 125000/6, или 20833 LOC или 20,833 SLOC.</p></div><span id="lnkc173ad3270414120bb61c1a1aad716c2"> </span><h2 align="left" class="paragraph-headline-source">Преимущества при использовании LOC в качестве единиц измерения</h2><span id="lnk7c964b5f41464e1b8b38fd91f63a83f2"> </span><div class="section"><ul class="list-source"><li align="justify">эти единицы измерения широко распространены и могут легко адаптироваться; </li><li align="justify">позволяют выполнять сопоставление методов измерения размеров и производительности в различных группах разработчиков; </li><li align="justify">непосредственно связаны с конечным продуктом; </li><li align="justify">единицы LOC легко оцениваются еще до завершения проекта; </li><li align="justify">оценка размеров ПО производится на основе точки зрения разработчика - физическая оценка созданного продукта (количество написанных строк кода); </li><li align="justify">действия по непрерывному улучшению базируются на оценочной технике - спрогнозированный размер может быть легко сопоставлен с реальным размером в ходе осуществления постпроектного анализа. (Насколько точной была оценка? Что означает определенный процент? Что может быть изучено в рамках оценки размера следующего проекта?).     </li></ul></div><span id="lnk7e7cad9923da40e9b73065cc27afba85"> </span><h2 align="left" class="paragraph-headline-source">Недостатки, связанные с применением метода LOC</h2><span id="lnk53293e994e934affa1a2dc71e7fd5584"> </span><div class="section"><ul class="list-source"><li align="justify">единицы измерения LOC затруднительны в применении при оценке размера ПО на ранних стадиях жизненного цикла разработки; </li><li align="justify">исходные инструкции могут различаться в зависимости от типов языков программирования, методов проектирования, стиля и способностей программиста; </li><li align="justify">применение методов оценки с помощью подсчета количества строк кода не регламентируется промышленными стандартами (например, ISO); </li><li align="justify">разработка ПО может быть связана с большими затратами, которые прямо не зависят от размеров программного кода - "фиксированные затраты", такие как спецификации требований и пользовательские документы не включены в прямые затраты на кодирование; </li><li align="justify">программисты могут быть незаслуженно премированы за достижение высоких показателей LOC в случае, если служба менеджмента по ошибке посчитает это признаком высокой продуктивности, но при этом будет отсутствовать тщательно разработанный проект; исходный код не является самоцелью при создании готового продукта - главную роль играют функциональные свойства и показатели производительности; </li><li align="justify">при подсчете количества единиц LOC следует различать автоматический и вручную созданный код - эта задача является более сложной, чем "простой подсчет", который может быть выполнен на основе листинга, сгенерированного компилятором, либо с помощью утилиты, выполняющей подсчет строк программного кода; </li><li align="justify">показатели LOC не могут применяться при осуществлении нормализации в случае, если применяемые платформы или языки являются различными; </li><li align="justify">единственный способ применения учета с помощью единиц измерения LOC по отношению к разрабатываемому ПО заключается в использовании метода аналогии на основе сравнения функциональных свойств у подобных программных продуктов, либо в использовании мнений экспертов (однако, эти методы не относятся к числу точных); </li><li align="justify">генераторы кода зачастую продуцируют чрезмерный объем кода, в результате чего </li><li align="justify">искажаются показатели LOC. </li></ul></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2005 ХНУРЭ, Программной инженерии, Ревенчук Илона Анатольевна, <a href="mailto:fpo@kture.kharkov.ua">fpo@kture.kharkov.ua</a><br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>