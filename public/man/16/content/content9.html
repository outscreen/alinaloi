<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Менеджмент проектов программного обеспечения — Теория — Влияние эффектов повторного использования на размер ПО </title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/help-system1.html">Подсистема помощи</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Менеджмент проектов программного обеспечения</div><div id="courseSubTitle">Раздел 16 - Оценка размера и возможности повторного использования ПО : Влияние эффектов повторного использования на размер ПО </div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><a href="../../16/content/preface1.html">Введение</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../16/content/content1.html">Введение</a></li><li><a href="../../16/content/content2.html">Проблемы и риски, связанные с оцениванием размера ПО</a></li><li><a href="../../16/content/content3.html">Определение размеров программного продукта</a></li><li><a href="../../16/content/content4.html">Оценка размера ПО в процессе разработки проекта </a></li><li><a href="../../16/content/content5.html">Метод функциональных точек</a></li><li><a href="../../16/content/content6.html">Метод точек свойств</a></li><li><a href="../../16/content/content7.html">Метод объектных точек</a></li><li><a href="../../16/content/content8.html">Метод оценивания Wideband Delphi</a></li><li><a href="../../16/content/content9.html">Влияние эффектов повторного использования на размер ПО </a></li><li><a href="../../16/content/content10.html">Резюме </a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../16/content/example1.html">Вопросы для самопроверки</a></li></ul><li><a href="../../16/content/conclusion1.html">Выводы</a></li><li><a href="../../16/styles/reference.html">Перечень ссылок</a></li><li><a href="../../16/16.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnkf064ac4e49d34042b09cd8244b72d846"> </span><h1 align="left" class="headline-source">Влияние эффектов повторного использования на размер ПО </h1><span id="lnk3ce38c156a18417990e08aacc2296771"> </span><div class="section"><p align="justify" class="paragraph-source">     Многие программы происходят от предыдущих версий этих же программ. В  результате может быть достигнута экономия средств и/или времени, а также возрасти уровень качества. Однако при повторном использовании могут расходоваться  дополнительные средства и время, а уровень качества будет низким. </p><p align="justify" class="paragraph-source">     Повторному использованию подлежат: код, тестовый код, тестовые условия,  тестовые процедуры, документация, дизайн, спецификации дизайна, спецификации требований и т.д. </p><p align="justify" class="paragraph-source">     Терминология повторного использования: </p><ul class="list-source"><li align="justify"><i><b>Новый код</b></i> - это код, разработанный для нового приложения, который не  включает большие порции ранее написанного кода. </li><li align="justify"><i><b>Модифицируемый код</b></i>- это код, разработанный для предыдущих приложений, который становился пригодным для использования в новым приложениях после внесения умеренного объема изменений. </li><li align="justify"><i><b>Повторно используемый код</b></i> - это код, разработанный для предыдущих  приложений, который будет пригодным для новых приложений без внесения каких-либо изменений. </li><li align="justify"><i><b>Наследственный код</b></i> - это код, разработанный для предыдущих приложений,  использование которого ожидается новым приложением. </li></ul><p align="justify" class="paragraph-source">     Почему же код считается "модифицируемым" в случае, если он будет подвергаться лишь незначительным изменениям? Код, повторно используемый, в полном объеме, имеет идентичную документацию, идентичные тестовые процедуры и код, но лишь одну копию с целью поддержки библиотеки менеджмента конфигурирования. Даже если изменяется единственная строка комментария, две копии кода, тестовый код, документация и прочее должны поддерживаться в библиотеке управления  конфигурированием. Если изменяется лишь одна строка исполняемого кода, подвергается  изменению тестовый код и документация. </p><p align="justify" class="paragraph-source">     При использовании наследственного кода имейте в виду, что он может быть  снабжен документацией плохого качества, могут отсутствовать тестовый код либо  процедуры. Для этого кода может отсутствовать тщательно проработанный проект, и он может не отвечать стандартам качества.      </p><p align="justify" class="paragraph-source">     Первый этап при оценке систем, которые могут повторно использовать код,  заключается в отделении нового кода от модифицируемого и повторно используемого кода. Это необходимо по той причине, что модифицируемый и повторно  используемый код практически никогда не может быть использован непосредственно, - для выполнения интеграции этого кода требуются некоторые изменения, в результате чего возрастает размер кода и объем трудозатрат, требуемых для реализации  подобных изменений. Соответствующий пример приводится в таблице на рис.16.14.</p></div><span id="lnkf596a153434b4b45b0187798a10bae98"> </span><div class="section"></div><span id="lnk3569fdb32dc6454182fd5990b7842c30"> </span><p align="center" class="inline-picture-source"><img src="../res/files/ris_16x14_0_.JPG" height="213px" width="555px" alt="" /> </p><p align="center" class="inline-picture-source"></p><p align="center" class="inline-picture-source">Рисунок 16.14 - Разделение новых, модифицируемых и повторно используемых строк кода</p><span id="lnk31b7cd32e8c84c73b2424ce076501208"> </span><div class="section"></div><span id="lnk6831581977fa4cd6bf2635462d65a3af"> </span><div class="section"><p align="justify" class="paragraph-source">     А теперь возникает вопрос о том, как можно узнать, в какой степени компонент может быть модифицируемым или повторно используемым? Обратимся к компонентам 4 и 5 в таблице рис.16.15. Правило "большого пальца" говорит о необходимости  проверки наименьшего уровня, известного для единицы либо модуля (обычно около 100 LOС). Если единица в целом не была изменена, она может "повторно  использоваться". Если единица была изменена (пусть даже речь идет об одном комментарии или выполняемом операторе), она является "модифицируемой". Если более чем 50% кода единицы было изменено, рассматривайте ее как "новую". Кроме того, как только модифицируемый код был идентифицирован, его можно разбить на категории,  представляющие тип модификации. Широко используемый подход заключается в том, чтобы отделять модификации, предназначенные для корректировки дефектов, от модификаций, направленных на добавление расширений. Как видно, таблицы рис.16.14 и 16.15 весьма похожи за исключением одного выполненного разделения.</p></div><span id="lnkc4100f0bbcee4857b4ac1e07a47d664f"> </span><div class="section"></div><span id="lnk7452e83cb22f429686f5180a912b8019"> </span><p align="center" class="inline-picture-source"><img src="../res/files/ris_16x15_0_.JPG" height="322px" width="559px" alt="" /> </p><p align="center" class="inline-picture-source"></p><p align="center" class="inline-picture-source">Рисунок 16.15 - Различные типы модифицируемого кода </p><span id="lnkd0a7291b221d48cf9243c49860aaf2b5"> </span><div class="section"></div><span id="lnk4fe165d8e6104d4fbfcd2980158374e2"> </span><div class="section"><p align="justify" class="paragraph-source">     После завершения оценки общего объема разработанного программного кода  повторно используемый код будет преобразован в "эквивалентный" новый код. В ходе процесса преобразования ставится цель минимизировать объем трудозатрат при  внедрении повторно используемого или модифицируемого кода по сравнению с  внедрением нового программного кода. Обычно определяется множитель преобразования с целью отражения количества трудозатрат, сэкономленных при повторном  использовании кода. Предполагая наличие хронологического выравнивания множителей  преобразования, можно заключить, что в этом случае выполняется простая калькуляция. </p><p align="justify" class="paragraph-source">     Возвращаясь к примеру рис.16.16, можно применить множители повторного  использования, свидетельствующие о том, что при внедрении повторно используемого ПО экономится примерно 70% трудозатрат по сравнению с внедрением нового ПО.</p></div><span id="lnk36ae5502db3d42b89870a5d073f18ec9"> </span><div class="section"></div><span id="lnk18042461cd444ac7850bd2f2b3fa9549"> </span><p align="center" class="inline-picture-source"><img src="../res/files/ris_16x16_0_.JPG" height="127px" width="542px" alt="" /> </p><p align="center" class="inline-picture-source"></p><p align="center" class="inline-picture-source">Рисунок 16.16 - Применение множителей повторного использования </p><span id="lnkd030c278601a4eb9bda679d29f49cf9f"> </span><div class="section"></div><span id="lnk2b42071a22a7434f916dc79b5f78cc5c"> </span><div class="section"><p align="justify" class="paragraph-source">     При использовании модифицируемых программ экономия составляет примерно 40%. Это говорит о том, что объем трудозатрат, требуемых при написании 5121 строк  повторно используемого, модифицируемого и нового кода эквивалентен объему  трудозатрат в случае написания 3567 строк нового кода. </p><p align="justify" class="paragraph-source">     Множители повторного использования вычисляются на основании опыта.  </p><p align="justify" class="paragraph-source">     Множители, равные 30% (трудозатраты на создание повторно используемого кода) и 60% (трудозатраты на создание модифицируемого кода) наблюдаются в сотнях проектов. Однако в данном случае речь идет о средних значениях и возможный диапазон будет шире. Наилучшим индикатором достигаемого размера и понесенных трудозатрат в вашей организации являются фактические данные, полученные в ней, -  отслеживайте оценки и фактические данные в хронологической базе данных. Типичные множители повторного использования приведены в таблице рис. 16.17. </p></div><span id="lnk3a14bee9c2194afd80136cd33b89c36f"> </span><div class="section"></div><span id="lnk6b5f28632af74d2ea78186ee9da47941"> </span><p align="center" class="inline-picture-source"><img src="../res/files/ris_16x17_0_.JPG" height="127px" width="417px" alt="" /> </p><p align="center" class="inline-picture-source"></p><p align="center" class="inline-picture-source">Рисунок 16.17 - Типичные множители повторного использования </p><span id="lnk742b834323cc4635995e490c5ba18392"> </span><div class="section"></div><span id="lnk3bc916d0441c436f811b30f327a8b5ef"> </span><div class="section"><p align="justify" class="paragraph-source">     Будьте особенно внимательны при повторном использовании кода. Можно достичь большей точности при повторном использовании кода, если более внимательно присмотреться к процессу и повторно использовать характеристики. </p><p align="justify" class="paragraph-source">     Возвращаясь к нашему примеру, заметим, что первый шаг заключается в проверке процесса и в определении процента от общего количества трудозатрат, понесенных на каждом шаге разработки нового кода. </p><p align="justify" class="paragraph-source">     Предположим, нам известно о том, что данная организация тратит 18% своего времени на разработку требований, 25% времени - на дизайн, 25% времени - на  кодирование и тестирование, а 32% времени - на выполнение интеграции (в данном примере рассматриваются лишь четыре фазы жизненного цикла). </p><p align="justify" class="paragraph-source">     Как показано в таблице рис. 16.18, на разработку нового кода уходит максимальное  количество трудозатрат. В случае применения повторно используемого и  модифицируемого кода трудозатраты будут меньшими. Отметим, что, вместо обычных 100%, модифицируемый код требует лишь 20% трудозатрат на этапе формулировки требований, а повторно используемый код - лишь 10% трудозатрат. </p><p align="justify" class="paragraph-source">     Вместо 100% трудозатрат на этапе разработки проекта, модифицируемое ПО  требует 40% трудозатрат, а повторно используемое ПО вообще не нуждается в  разработке проекта (0%). Показатель 40% появляется по той причине, что потребуется  разработать план тестирования модифицируемого ПО, а также вполне возможно, что  придется специальным образом переработать часть ПО. Таким образом отчетливо просматривается важность повторного использования. </p><p align="justify" class="paragraph-source">     Вместо 100% трудозатрат на этапе кодирования и тестирования единицы,  необходимых при разработке новых программ, модифицируемое ПО требует лишь 70% трудозатрат, а повторно используемое ПО является полностью "свободным" от  трудозатрат. При использовании "чистого", повторно используемого ПО данный  показатель равен нулю. Если будет изменена лишь одна строка кода, все ПО будет  считаться модифицируемым. </p><p align="justify" class="paragraph-source">     Трудозатраты по интеграции кода не будут сильно уменьшены даже в случае применения модифицируемого или повторно используемого кода. Даже в случае чистого повторно используемого кода трудозатраты по интеграции часто  составляют 50%-100%. На каждой фазе процесса эффект от повторного использования кода может  определяться после того, как установлено процентное значение для каждой повторно  используемой категории. </p><p align="justify" class="paragraph-source">     В таблице рис. 16.18 демонстрируется, что включение повторно  используемого либо модифицируемого кода в любом случае может привести к экономии размера, трудозатрат, времени по графику или затрат денежных средств.</p></div><span id="lnk298f489a82ef450bb082424237cce3e8"> </span><div class="section"></div><span id="lnkec4c1a7effd34bbf8d6567329d37b6db"> </span><p align="center" class="inline-picture-source"><img src="../res/files/ris_16x18_0_.JPG" height="259px" width="567px" alt="" /> </p><p align="center" class="inline-picture-source"></p><p align="center" class="inline-picture-source">Рисунок 16.18 - Применение метода точной оценки в повторно используемом или модифицируемом коде</p><span id="lnk69c2098ec10e4c83bd055e3050e853bf"> </span><div class="section"></div><span id="lnkbab510f802d246a38399d6bef5357865"> </span><h2 align="left" class="paragraph-headline-source">Оценка трудозатрат </h2><span id="lnked254adfd8b54c1392c356bbc6249d21"> </span><div class="section"><p align="left" class="paragraph-source">     После того, как размер программного продукта был оценен, можно перейти к оценке трудозатрат, понесенных на производстве этого продукта. </p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2005 ХНУРЭ, Программной инженерии, Ревенчук Илона Анатольевна, <a href="mailto:fpo@kture.kharkov.ua">fpo@kture.kharkov.ua</a><br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>